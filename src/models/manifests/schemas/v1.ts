/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * List of implement device profiles
 */
export type Implements = string | string[];
/**
 * Lua firmware should send/accept data according to type declarations. Supported types are: boolean, string, integer, float
 */
export type TypeField = "boolean" | "string" | "integer" | "float" | "array_of_strings";
/**
 * List of aliases for command, property or telemetry attribute
 */
export type Aliases = string | string[];
/**
 * Enumerables restrict possible field values. Values should be of the same type as defined in `type` field.
 */
export type EnumField =
  | (string | number)[]
  | {
      [k: string]: EnumItemField;
    };

/**
 * Device Blueprint for Enapter Cloud
 */
export interface BlueprintManifest {
  /**
   * Version of Enapter Cloud Blueprint used for this manifest
   */
  blueprint_spec: "device/1.0";
  implements?: Implements;
  implements_draft?: Implements;
  /**
   * Display name to be shown to users in Blueprints Marketplace.
   */
  display_name: string;
  /**
   * Description to be shown to users in Blueprints Marketplace.
   */
  description?: string;
  /**
   * Device icon to show in the UI. Must be one from [the full list of available icons](https://static.enapter.com/rn/icons/material-community.html).
   */
  icon?: string;
  /**
   * A company identifier, that manufactures a hardware.
   */
  vendor?: string;
  /**
   * Properties are Device metadata which unlike telemetry does not change during device normal operation. It could be firmware version, device model, serial number and similar.
   */
  properties?: {
    [k: string]: Property;
  };
  /**
   * Telemetry contains of Device's metrics or states which must be tracked during device operations as a timeseries data. For example, sensors data and internal device states goes into this category.
   */
  telemetry?: {
    [k: string]: TelemetryAttribute;
  };
  /**
   * Commands could be grouped. If command groups are declared, it's required to set group ID for each command. It's not necessary to use groups, but convenient when device has many commands.
   */
  command_groups?: {
    [k: string]: CommandGroup;
  };
  /**
   * Commands which can be performed on device. Lua firmware on the module must implement methods with names according to command IDs
   */
  commands?: {
    [k: string]: Command;
  };
  /**
   * Alerts are faulty device states, e.g. "overheated heatsink".
   * Lua firmware must send IDs of these alerts in `alerts` field inside telemetry JSON if device is in active alert state. All IDs sent by device, that not declared in this list will still be considered as alerts of severity `error` with display_name equal to alert ID.
   */
  alerts?: {
    [k: string]: Alert;
  };
  communication_module?: CommModule;
  /**
   * Communication modules section describes what modules should be used to implement Device integration.
   */
  communication_modules?: {
    [k: string]: CommModule1;
  };
  /**
   * Blueprint author username on GitHub.
   */
  author?: string;
  /**
   * Users, who have contributed to this blueprint.
   */
  contributors?: string[];
  support?: Support;
  /**
   * License type, which blueprint based on.
   */
  license?: string;
  verification_level?: VerificationLevel;
  /**
   * This interface was referenced by `BlueprintManifest`'s JSON-Schema definition
   * via the `patternProperty` "^\.\w*$".
   */
  [k: string]: unknown;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` "^[A-Za-z][A-Za-z0-9_]*$".
 */
export interface Property {
  /**
   * Defines which communication_module would be the source of this information. Same property from another communication modules will be ignored, use different names if you need to. This field is required if Blueprint has several communication modules. Refer to `communication_modules` field description.
   */
  communication_module?: string;
  type: TypeField;
  implements?: Implements;
  aliases?: Aliases;
  /**
   * Display name which will be shown to the users in the UI.
   */
  display_name: string;
  /**
   * Optional property description is shown to user in UIs. If not given, description will be empty.
   */
  description?: string;
  enum?: EnumField;
  [k: string]: unknown;
}
/**
 * One of the possible fields' values.
 */
export interface EnumItemField {
  /**
   * Display name which will be shown to the users in the UI.
   */
  display_name?: string;
  /**
   * Optional description to show in UIs. If not provided, will be omitted.
   */
  description?: string;
  /**
   * Optional color to show in UIs. If not provided, will be omitted.
   */
  color?: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` "^[A-Za-z][A-Za-z0-9_]*$".
 */
export interface TelemetryAttribute {
  /**
   * Defines which communication_module would be the source of this information. Same property from another communication modules will be ignored, use different names if you need to. This field is required if Blueprint has several communication modules. Refer to `communication_modules` field description.
   */
  communication_module?: string;
  type: TypeField;
  implements?: Implements;
  aliases?: Aliases;
  /**
   * Display name which will be shown to the users in the UI.
   */
  display_name: string;
  /**
   * Optional property description is shown to user in UIs. If not given, description will be empty.
   */
  description?: string;
  enum?: EnumField;
  /**
   * Unit identifier, used in charts and telemetry-related UIs. Most of the commonly used units are covered in the supported units list (link). You can still provide your own units as a string value.
   */
  unit?: string;
  /**
   * User should have required access level for reading telemetry
   */
  access_level?: "readonly" | "user" | "owner" | "installer" | "vendor" | "system";
  [k: string]: unknown;
}
export interface CommandGroup {
  /**
   * Display name which will be shown as a heading of the commands group on the commands screen.
   */
  display_name: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` "^[A-Za-z][A-Za-z0-9_]*$".
 */
export interface Command {
  implements?: Implements;
  aliases?: Aliases;
  /**
   * Define in which command group this command will belong to. Should match with one of the command groups name. Refer to `command_groups` field description
   */
  group: string;
  /**
   * Defines which communication_module will handle this command. This field is required if Blueprint has several communication modules. Refer to `communication_modules` field description.
   */
  communication_module?: string;
  /**
   * Display name which will be shown to the users in the UI.
   */
  display_name: string;
  /**
   * Optional command description to show in UIs. If not provided, will be omitted.
   */
  description?: string;
  /**
   * Arguments to be supplied to command. Corresponding function in Lua firmware should accept these as a named arguments.
   */
  arguments?: {
    [k: string]: CommandArgument;
  };
  /**
   * Virtual commands are not implemented in device Lua firmware. Instead communication module's `virtual_commands.lua` runs in Cloud and translates this command into another command calls, which in it's turn are implemented in device Lua firmware. Commands marked as `virtual` must be defined as a function in `virtual_commands.lua`.
   */
  virtual?: boolean;
  ui?: {
    /**
     * Optional command icon, string key from [Material UI](https://static.enapter.com/rn/icons/material-community.html)
     */
    icon?: string;
    /**
     * Optional property for displaying command in quick access command menu in mobile
     */
    mobile_quick_access?: boolean;
    [k: string]: unknown;
  };
  confirmation?: {
    /**
     * Main text for confirmation dialog before execution command
     */
    description?: string;
    /**
     * Severity level for confirmation dialog
     */
    severity: "info" | "warning";
    /**
     * Title for confirmation dialog before execution command
     */
    title: string;
    [k: string]: unknown;
  };
  /**
   * User should have required access level for executing command
   */
  access_level?: "readonly" | "user" | "owner" | "installer" | "vendor" | "system";
  /**
   * The name of the command which should be used for reading the values for the arguments form pre-population. This read command should return a Lua table with the same keys as the arguments in the write command.
   */
  populate_values_command?: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` "^[A-Za-z][A-Za-z0-9_]*$".
 */
export interface CommandArgument {
  /**
   * Display name which will be shown to the users in the UI.
   */
  display_name: string;
  /**
   * A more detailed description of the argument. It will be shown next to the argument field in the arguments form.
   */
  description?: string;
  required?: boolean;
  type: TypeField;
  min?: number;
  max?: number;
  enum?: EnumField;
  /**
   * Predefined format for string type can be used.
   */
  format?: string;
  /**
   * Default value to be supplied to command if is not present in user input. Must be the same type as declared type of the argument
   */
  default?: string | number | boolean;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` "^[A-Za-z0-9_-]+$".
 */
export interface Alert {
  /**
   * Supported severities are: info, warning, error.
   */
  severity: "info" | "warning" | "error";
  /**
   * Vendor-specific alert code, which may be useful, for example, for checking in the device manual.
   */
  code?: string;
  /**
   * Period in duration format (1m, 2m30s) when soft fail become hard fail. If empty grace period is equal zero.
   */
  grace_period?: string;
  /**
   * Display name which will be shown to the users in the UI.
   */
  display_name: string;
  /**
   * Optional alert description to show in UIs. If not provided, will be omitted.
   */
  description?: string;
  [k: string]: unknown;
}
/**
 * Communication modules section describes what modules should be used to implement Device integration.
 */
export interface CommModule {
  /**
   * Product identifier of Enapter Communication Module.
   */
  product: string;
  /**
   * Lua firmware description. See tutorial https://developers.enapter.com/docs/tutorial/lua-complex/intro. Cannot be used alongside with lua_file.
   */
  lua?: {
    /**
     * Directory with Lua files. It should contain main.lua as an entrypoint. Cannot be used alongside with file.
     */
    dir?: string;
    /**
     * Lua script. Cannot be used alongside with dir.
     */
    file?: string;
    /**
     * Rockspec file name. Cannot be used alongside with dependencies.
     */
    rockspec?: string;
    /**
     * Lua script dependencies. Every item is a rockspec package. Cannot be used alongside with rockspec.
     */
    dependencies?: string[];
    /**
     * Allow to use luarocks dev packages.
     */
    allow_dev_dependencies?: boolean;
    /**
     * Optional mode to use for amalgamation.
     */
    amalg_mode?: ("isolate" | "nodebug") | ("isolate" | "nodebug")[];
    [k: string]: unknown;
  };
  /**
   * Lua script which will be uploaded on the module once given Blueprint is assigned to it. You can consider it as module firmware, which implements device interface declared in this Blueprint.
   */
  lua_file?: string;
  /**
   * In some cases we need to preprocess incoming device telemetry in Cloud. For example to parse bitmask (effective way to transfer many boolean values) into several boolean telemetry fields (more verbose and user-friendly way).
   */
  telemetry_preprocessor?: {
    lua_file: string;
    [k: string]: unknown;
  };
  /**
   * User input for command request may require preprocessing. Or one high-level user-friendly command can be split into several specific commands implemented in Lua firmware. Virtual commands can be used to achieve this.
   */
  virtual_commands?: {
    lua_file: string;
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
export interface CommModule1 {
  /**
   * Product identifier of Enapter Communication Module.
   */
  product: string;
  /**
   * Lua firmware description. See tutorial https://developers.enapter.com/docs/tutorial/lua-complex/intro. Cannot be used alongside with lua_file.
   */
  lua?: {
    /**
     * Directory with Lua files. It should contain main.lua as an entrypoint. Cannot be used alongside with file.
     */
    dir?: string;
    /**
     * Lua script. Cannot be used alongside with dir.
     */
    file?: string;
    /**
     * Rockspec file name. Cannot be used alongside with dependencies.
     */
    rockspec?: string;
    /**
     * Lua script dependencies. Every item is a rockspec package. Cannot be used alongside with rockspec.
     */
    dependencies?: string[];
    /**
     * Allow to use luarocks dev packages.
     */
    allow_dev_dependencies?: boolean;
    /**
     * Optional mode to use for amalgamation.
     */
    amalg_mode?: ("isolate" | "nodebug") | ("isolate" | "nodebug")[];
    [k: string]: unknown;
  };
  /**
   * Lua script which will be uploaded on the module once given Blueprint is assigned to it. You can consider it as module firmware, which implements device interface declared in this Blueprint.
   */
  lua_file?: string;
  /**
   * In some cases we need to preprocess incoming device telemetry in Cloud. For example to parse bitmask (effective way to transfer many boolean values) into several boolean telemetry fields (more verbose and user-friendly way).
   */
  telemetry_preprocessor?: {
    lua_file: string;
    [k: string]: unknown;
  };
  /**
   * User input for command request may require preprocessing. Or one high-level user-friendly command can be split into several specific commands implemented in Lua firmware. Virtual commands can be used to achieve this.
   */
  virtual_commands?: {
    lua_file: string;
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Support information contains web address and email.
 */
export interface Support {
  /**
   * Web address when user can to get any support about blueprint.
   */
  url?: string;
  /**
   * Email address for user's support mails.
   */
  email?: string;
  [k: string]: unknown;
}
/**
 * Enapter and the developers community assign verification levels to Blueprints to ensure the best performance.
 */
export interface VerificationLevel {
  [k: string]: unknown;
}
